diff -urN cdrtools-3.01.orig/RULES/cc-gcc.rul cdrtools-3.01/RULES/cc-gcc.rul
--- cdrtools-3.01.orig/RULES/cc-gcc.rul	2013-11-13 20:31:03.000000000 +0100
+++ cdrtools-3.01/RULES/cc-gcc.rul	2014-03-25 15:52:33.734375000 +0100
@@ -71,7 +71,7 @@
 
 CCCC=		@echo "	==> COMPILING \"$@\""; $(CC_COM)
 CC++ =		@echo "	==> COMPILING \"$@\""; $(CC++_COM)
-LDCC=		@echo "	==> LINKING \"$@\""; $(CC_COM)
+LDCC=		@echo "	==> LINKING \"$@\""; $(CC_COM) -Wl,--strip-all
 LDCC++ =	@echo "	==> LINKING \"$@\""; $(CC++_COM)
 DYNLD=		@echo "	==> LINKING dynamic library \"$@\""; $(CC_COM)
 DYNLDC++ =	@echo "	==> LINKING dynamic library \"$@\""; $(CC++_COM)
diff -urN cdrtools-3.01.orig/include/schily/unistd.h cdrtools-3.01/include/schily/unistd.h
--- cdrtools-3.01.orig/include/schily/unistd.h	2013-04-24 23:17:03.000000000 +0200
+++ cdrtools-3.01/include/schily/unistd.h	2014-03-25 15:52:33.734375000 +0100
@@ -135,7 +135,7 @@
  * Maybe we need a lot more definitions here...
  * It is not clear whether we should have prototyped definitions.
  */
-#ifndef	_MSC_VER
+#if	!defined(_MSC_VER) || !defined(_WIN32)
 /*
  * MS C comes with broken prototypes in wrong header files (in our case, the
  * wrong prototype is in io.h). Avoid to redefine the broken MS stuff with
diff -urN cdrtools-3.01.orig/include/schily/windows.h cdrtools-3.01/include/schily/windows.h
--- cdrtools-3.01.orig/include/schily/windows.h	2013-10-26 13:33:27.000000000 +0200
+++ cdrtools-3.01/include/schily/windows.h	2014-03-25 15:52:33.750000000 +0100
@@ -67,7 +67,9 @@
 #endif	/* defined(__CYGWIN32__) || defined(__CYGWIN__) */
 
 
+#ifndef __MINGW32__
 #define	BOOL	WBOOL		/* This is the Win BOOL		*/
+#endif
 #define	format	__ms_format	/* Avoid format parameter hides global ... */
 
 #ifdef	timerclear		/* struct timeval has already been declared */
@@ -76,7 +78,9 @@
 
 #include <windows.h>
 
+#ifndef __MINGW32__
 #undef	BOOL			/* MS Code uses WBOOL or #define BOOL WBOOL */
+#endif
 #undef	format			/* Return to previous definition */
 #undef	timeval
 
diff -urN cdrtools-3.01.orig/libscg/scg/aspi-win32.h cdrtools-3.01/libscg/scg/aspi-win32.h
--- cdrtools-3.01.orig/libscg/scg/aspi-win32.h	2012-12-31 16:57:33.000000000 +0100
+++ cdrtools-3.01/libscg/scg/aspi-win32.h	2014-03-25 15:52:33.750000000 +0100
@@ -5,7 +5,7 @@
 
 #include <schily/windows.h>
 
-#ifdef	_MSC_VER
+#if	!defined(_MSC_VER) || !defined(_WIN32)
 #define	PACKED
 #else
 #if	!defined(PACKED) && defined(__GNUC__)
@@ -197,7 +197,7 @@
   DWORD     AB_Reserved;
 } PACKED ASPI32BUFF, *PASPI32BUFF, FAR *LPASPI32BUFF;
 
-typedef struct 
+typedef struct
 {
   BYTE      SRB_Cmd;
   BYTE      SRB_Status;
diff -urN cdrtools-3.01.orig/libschily/mkdirs.c cdrtools-3.01/libschily/mkdirs.c
--- cdrtools-3.01.orig/libschily/mkdirs.c	2014-01-02 16:20:09.000000000 +0100
+++ cdrtools-3.01/libschily/mkdirs.c	2014-03-25 15:52:33.765625000 +0100
@@ -28,7 +28,9 @@
 #include <schily/string.h>
 #include <schily/standard.h>
 #include <schily/schily.h>
-
+#ifdef __MINGW32__
+#define mkdir(a,b) mkdir(a)
+#endif
 #if defined(ENOTEMPTY) && ENOTEMPTY != EEXIST
 #define	is_eexist(err)	((err) == EEXIST || (err) == ENOTEMPTY)
 #else
diff -urN cdrtools-3.01.orig/libschily/stdio/schilyio.h cdrtools-3.01/libschily/stdio/schilyio.h
--- cdrtools-3.01.orig/libschily/stdio/schilyio.h	2010-08-23 21:57:34.000000000 +0200
+++ cdrtools-3.01/libschily/stdio/schilyio.h	2014-03-25 15:52:33.765625000 +0100
@@ -169,7 +169,9 @@
 /*
  * Define prototypes to verify if our interface is right
  */
+#if	!defined(_MSC_VER) || !defined(_WIN32)
 extern	int	_filbuf			__PR((FILE *));
+#endif
 #	else
 /*
  * no filbuf() but this will not happen on USG_STDIO systems.
diff -urN cdrtools-3.01.orig/mkisofs/Makefile cdrtools-3.01/mkisofs/Makefile
--- cdrtools-3.01.orig/mkisofs/Makefile	2013-04-24 20:57:48.000000000 +0200
+++ cdrtools-3.01/mkisofs/Makefile	2014-03-25 15:52:33.781250000 +0100
@@ -40,17 +40,20 @@
 CPPOPTS +=	-DUSE_ICONV
 CPPOPTS +=	-DINS_BASE=\"${INS_BASE}\"
 CPPOPTS +=	-DTEXT_DOMAIN=\"SCHILY_cdrtools\"
+CPPOPTS +=  -DDUPLICATES_ONCE
+CPPOPTS +=  -DFORCE_UPPERCASE
 
 CFILES=		mkisofs.c tree.c write.c hash.c rock.c inode.c udf.c multi.c \
 		joliet.c match.c name.c eltorito.c boot.c isonum.c \
 		scsi.c \
 		apple.c volume.c desktop.c mac_label.c stream.c \
 		ifo_read.c dvd_file.c dvd_reader.c \
-		walk.c
+		walk.c md5c.c
 HFILES=		apple.h bootinfo.h defaults.h diskmbr.h \
 		iso9660.h mac_label.h mactypes.h match.h \
 		mkisofs.h sunlabel.h udf.h udf_fs.h vms.h \
-		ifo_read.h dvd_file.h dvd_reader.h bswap.h ifo_types.h
+		ifo_read.h dvd_file.h dvd_reader.h bswap.h ifo_types.h \
+    md5.h mytype.h
 
 #
 # LIB_CAP is needed for Linux capability support in librscg.
diff -urN cdrtools-3.01.orig/mkisofs/config.h cdrtools-3.01/mkisofs/config.h
--- cdrtools-3.01.orig/mkisofs/config.h	1970-01-01 01:00:00.000000000 +0100
+++ cdrtools-3.01/mkisofs/config.h	2014-03-25 15:52:33.781250000 +0100
@@ -0,0 +1,36 @@
+/* @(#)config.h	1.1 97/05/16 Copyright 1997 J. Schilling */
+/*
+ *	Adaption for mconfig.h from make file system.
+ *
+ *	Copyright (c) 1997 J. Schilling
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; see the file COPYING.  If not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <schily/mconfig.h>
+
+#ifdef	DUPLICATES_ONCE
+#if	__STDC__-0 != 0 || (defined PROTOTYPES && defined STDC_HEADERS)
+#define UINT_C(a)	(a##u)
+#define ULONG_C(a)	(a##ul)
+#define USHORT_C(a)	(a##uh)
+#define CONCAT(a,b)	a##b
+#else
+#define UINT_C(a)	((unsigned) a)
+#define ULONG_C(a)	((unsigned long) a)
+#define USHORT_C(a)	((unsigned short) a)
+#define CONCAT(a,b)	a/**/b
+#endif
+#endif
diff -urN cdrtools-3.01.orig/mkisofs/eltorito.c cdrtools-3.01/mkisofs/eltorito.c
--- cdrtools-3.01.orig/mkisofs/eltorito.c	2012-12-02 14:32:46.000000000 +0100
+++ cdrtools-3.01/mkisofs/eltorito.c	2014-03-25 15:52:33.796875000 +0100
@@ -547,6 +547,13 @@
 			if (verbose > 0)
 				fprintf(stderr, _("Emulating a 2880 kB floppy\n"));
 
+		/* El Torito 0x03 - 2.88 fake floppy image:
+		80 < Tracks <= 1024, 2 Heads, 36 Sectors per track */
+		} else if (nsectors > 5760 && nsectors%72 == 0 && nsectors <= 73728) {
+			boot_desc_entry->boot_media[0] = EL_TORITO_MEDIA_288FLOP;
+			if (verbose > 0)
+				fprintf(stderr, "Emulating a fake 2880 kB floppy (%2d/2/36)\n", nsectors/72);
+
 		} else if (nsectors == 2400) {
 			boot_desc_entry->boot_media[0] = EL_TORITO_MEDIA_12FLOP;
 			if (verbose > 0)
diff -urN cdrtools-3.01.orig/mkisofs/hash.c cdrtools-3.01/mkisofs/hash.c
--- cdrtools-3.01.orig/mkisofs/hash.c	2010-12-19 20:16:30.000000000 +0100
+++ cdrtools-3.01/mkisofs/hash.c	2014-03-25 15:52:33.796875000 +0100
@@ -47,6 +47,8 @@
  * allow to disable the mkisofs inode cache.
  */
 
+/* DUPLICATES_ONCE Alex Kopylov cdrtools@bootcd.ru 19.06.2004 */
+
 #include "mkisofs.h"
 #include <schily/schily.h>
 
@@ -56,11 +58,17 @@
 
 static struct file_hash *hash_table[NR_HASH];
 
+#ifdef	DUPLICATES_ONCE
+#define	MD5_FAST_SIZE	65536
+#define	UNIQUE_FILES_HASH_FN(SIZE)	(SIZE % NR_HASH)
+static struct file_hash *unique_files_hash_table[NR_HASH];
+#endif
+
 #ifdef	HASH_DEBUG
 EXPORT	void		debug_hash	__PR((void));
 #endif
 EXPORT	void		add_hash	__PR((struct directory_entry *spnt));
-EXPORT	struct file_hash *find_hash	__PR((dev_t dev, ino_t inode));
+EXPORT	struct file_hash *find_hash	__PR((struct directory_entry *spnt));
 EXPORT	void		flush_hash	__PR((void));
 EXPORT	void		add_directory_hash __PR((dev_t dev, ino_t inode));
 EXPORT	struct file_hash *find_directory_hash __PR((dev_t dev, ino_t inode));
@@ -70,6 +78,10 @@
 LOCAL	BOOL		isoname_endsok	__PR((char *name));
 EXPORT	int		delete_file_hash __PR((struct directory_entry *de));
 EXPORT	void		flush_file_hash	__PR((void));
+#ifdef	DUPLICATES_ONCE
+LOCAL	struct directory_entry *compare_files __PR((struct directory_entry *spnt1, struct directory_entry *spnt2));
+LOCAL	unsigned char	*MD5File	__PR((char *name, size_t size));
+#endif
 
 #ifdef	HASH_DEBUG
 EXPORT void
@@ -120,58 +132,91 @@
 							spnt->name);
 		};
 
+#ifdef	DUPLICATES_ONCE
+	if (!cache_inodes && !duplicates_once)
+#else
 	if (!cache_inodes)
+#endif
 		return;
-	if (spnt->dev == UNCACHED_DEVICE &&
-	    (spnt->inode == TABLE_INODE || spnt->inode == UNCACHED_INODE)) {
+	if (spnt->dev == (dev_t) UNCACHED_DEVICE ||
+				spnt->inode == UNCACHED_INODE) {
 		return;
 	}
-	hash_number = HASH_FN((unsigned int) spnt->dev,
-						(unsigned int) spnt->inode);
 
 #if 0
 	if (verbose > 1)
 		fprintf(stderr, "%s ", spnt->name);
 #endif
 	s_hash = (struct file_hash *)e_malloc(sizeof (struct file_hash));
-	s_hash->next = hash_table[hash_number];
+#ifdef	DUPLICATES_ONCE
+	if (cache_inodes) {
+#endif
+		hash_number = HASH_FN((unsigned int) spnt->dev,
+						(unsigned int) spnt->inode);
+		s_hash->next = hash_table[hash_number];
+		hash_table[hash_number] = s_hash;
+#ifdef	DUPLICATES_ONCE
+	} else
+		s_hash->next = NULL;
+	if (duplicates_once && spnt->size && !(spnt->isorec.flags[0] & ISO_DIRECTORY)) {
+		hash_number = UNIQUE_FILES_HASH_FN((unsigned int) spnt->size);
+		s_hash->unique_files_next = unique_files_hash_table[hash_number];
+		unique_files_hash_table[hash_number] = s_hash;
+	} else
+		s_hash->unique_files_next = NULL;
+#endif
 	s_hash->inode = spnt->inode;
 	s_hash->dev = spnt->dev;
-	s_hash->nlink = 0;
 	s_hash->starting_block = spnt->starting_block;
 	s_hash->size = spnt->size;
-#ifdef SORTING
+#if	defined(SORTING) || defined(DUPLICATES_ONCE)
 	s_hash->de = spnt;
 #endif /* SORTING */
-	hash_table[hash_number] = s_hash;
 }
 
 #ifdef	PROTOTYPES
 EXPORT struct file_hash *
-find_hash(dev_t dev, ino_t inode)
+find_hash(struct directory_entry *spnt)
 #else
 EXPORT struct file_hash *
-find_hash(dev, inode)
-	dev_t	dev;
-	ino_t	inode;
+find_hash(spnt)
+	struct directory_entry	*spnt;
 #endif
 {
 	unsigned int    hash_number;
-	struct file_hash *spnt;
+	struct file_hash *spnt_ret;
 
+#ifdef	DUPLICATES_ONCE
+	if (!cache_inodes && !duplicates_once)
+#else
 	if (!cache_inodes)
+#endif
 		return (NULL);
-	if (dev == UNCACHED_DEVICE &&
-	    (inode == TABLE_INODE || inode == UNCACHED_INODE))
+	if (spnt->dev == (dev_t) UNCACHED_DEVICE || spnt->inode == UNCACHED_INODE)
 		return (NULL);
 
-	hash_number = HASH_FN((unsigned int) dev, (unsigned int) inode);
-	spnt = hash_table[hash_number];
-	while (spnt) {
-		if (spnt->inode == inode && spnt->dev == dev)
-			return (spnt);
-		spnt = spnt->next;
-	};
+#ifdef	DUPLICATES_ONCE
+	if (cache_inodes) {
+#endif
+		hash_number = HASH_FN((unsigned int) spnt->dev, (unsigned int) spnt->inode);
+		spnt_ret = hash_table[hash_number];
+		while (spnt_ret) {
+			if (spnt->inode == spnt_ret->inode && spnt->dev == spnt_ret->dev)
+				return (spnt_ret);
+			spnt_ret = spnt_ret->next;
+		}
+#ifdef	DUPLICATES_ONCE
+	}
+	if (duplicates_once && spnt->size && !(spnt->isorec.flags[0] & ISO_DIRECTORY)) {
+		hash_number = UNIQUE_FILES_HASH_FN((unsigned int) spnt->size);
+		spnt_ret = unique_files_hash_table[hash_number];
+		while (spnt_ret) {
+			if (compare_files(spnt, spnt_ret->de))
+				return (spnt_ret);
+			spnt_ret = spnt_ret->unique_files_next;
+		}
+	}
+#endif
 	return (NULL);
 }
 
@@ -185,18 +230,108 @@
 	struct file_hash	*fh;
 	struct file_hash	*fh1;
 	int			i;
+	struct file_hash	**ht = hash_table;
+#ifdef	DUPLICATES_ONCE
+	struct file_hash	**ht1 = unique_files_hash_table;
+
+	if (!cache_inodes) {
+		ht = unique_files_hash_table;
+		ht1 = hash_table;
+	}
+#endif
 
 	for (i = 0; i < NR_HASH; i++) {
-		fh = hash_table[i];
+		fh = ht[i];
 		while (fh) {
 			fh1 = fh->next;
 			free(fh);
 			fh = fh1;
 		}
-		hash_table[i] = NULL;
+		ht[i] = NULL;
+#ifdef	DUPLICATES_ONCE
+		ht1[i] = NULL;
+#endif
+	}
+}
+
+#ifdef	DUPLICATES_ONCE
+
+LOCAL struct directory_entry *
+compare_files(spnt1, spnt2)
+	struct directory_entry	*spnt1;
+	struct directory_entry	*spnt2;
+{
+	if(spnt1->size != spnt2->size)
+		return (NULL);
+
+	if(!spnt1->md5_fast)
+		if(!(spnt1->md5_fast = MD5File(spnt1->whole_name,
+			(spnt1->size > MD5_FAST_SIZE) ? MD5_FAST_SIZE : spnt1->size)))
+			return (NULL);
+
+	if(spnt1->size <= MD5_FAST_SIZE)
+		spnt1->md5_full = spnt1->md5_fast;
+
+	if(!spnt2->md5_fast)
+		if(!(spnt2->md5_fast = MD5File(spnt2->whole_name,
+			(spnt2->size > MD5_FAST_SIZE) ? MD5_FAST_SIZE : spnt2->size)))
+			return (NULL);
+
+	if(spnt2->size <= MD5_FAST_SIZE)
+		spnt2->md5_full = spnt2->md5_fast;
+
+	if(memcmp(spnt1->md5_fast, spnt2->md5_fast, 16*sizeof(unsigned char)))
+		return (NULL);
+
+	if(!spnt1->md5_full)
+		if(!(spnt1->md5_full = MD5File(spnt1->whole_name, spnt1->size)))
+			return (NULL);
+
+	if(!spnt2->md5_full)
+		if(!(spnt2->md5_full = MD5File(spnt2->whole_name, spnt2->size)))
+			return (NULL);
+
+	if(memcmp(spnt1->md5_full, spnt2->md5_full, 16*sizeof(unsigned char)))
+		return (NULL);
+
+	return (spnt2);
+}
+
+LOCAL unsigned char *
+MD5File(name, size)
+	char		*name;
+	size_t		size;
+{
+	MD5_CTX		md5_ctx;
+	FILE		*infile;
+	unsigned char	buf[32768];
+	unsigned char	*md5hash;
+	size_t		cnt;
+
+	MD5Init(&md5_ctx);
+
+	if((infile = fopen(name, "rb")) == NULL)
+		return (NULL);
+
+	while(size) {
+		cnt = (size > sizeof(buf)) ? sizeof(buf) : size;
+		if ((cnt = fread(buf, 1, cnt, infile)) <= 0) {
+			fclose(infile);
+			return (NULL);
+		}
+		MD5Update(&md5_ctx, buf, cnt);
+		size -= cnt;
 	}
+
+	fclose(infile);
+
+	md5hash = e_malloc(sizeof(unsigned char)*16);
+	MD5Final(md5hash, &md5_ctx);
+	return (md5hash);
 }
 
+#endif
+
 static struct file_hash *directory_hash_table[NR_HASH];
 
 #ifdef	PROTOTYPES
diff -urN cdrtools-3.01.orig/mkisofs/inode.c cdrtools-3.01/mkisofs/inode.c
--- cdrtools-3.01.orig/mkisofs/inode.c	2013-04-24 22:45:18.000000000 +0200
+++ cdrtools-3.01/mkisofs/inode.c	2014-03-25 15:52:33.812500000 +0100
@@ -120,7 +120,7 @@
 		s_entry = dpnt->contents;
 		for (s_entry = dpnt->contents; s_entry; s_entry = s_entry->next) {
 			if (s_entry->starting_block == 0) {
-				s_hash = find_hash(s_entry->dev, s_entry->inode);
+				s_hash = find_hash(s_entry);
 				/* find_directory_hash() ? */
 				if (s_hash)
 					s_entry->starting_block = s_hash->starting_block;
@@ -162,7 +162,7 @@
 				s_entry->dev = PREV_SESS_DEV;
 				s_entry->inode = null_inodes;
 			}
-			s_hash = find_hash(s_entry->dev, s_entry->inode);
+			s_hash = find_hash(s_entry);
 			if (s_hash) {
 				/*
 				 * Paranoia: Check for hashed files without proper inode #.
@@ -247,12 +247,12 @@
 						s_entry->whole_name : s_entry->name);
 				}
 			}
-			s_hash = find_hash(s_entry->dev, s_entry->inode);
+			s_hash = find_hash(s_entry);
 			if (s_hash) {
 				s_hash->nlink++;
 			} else {
 				add_hash(s_entry);
-				s_hash = find_hash(s_entry->dev, s_entry->inode);
+				s_hash = find_hash(s_entry);
 				if (s_hash == NULL) {
 					if (s_entry->dev == UNCACHED_DEVICE &&
 					    s_entry->inode == TABLE_INODE) {
@@ -300,7 +300,7 @@
 			if (s_entry->de_flags & RESOURCE_FORK)
 				continue;
 
-			s_hash = find_hash(s_entry->dev, s_entry->inode);
+			s_hash = find_hash(s_entry);
 			if (s_hash) {
 				update_nlink(s_entry, s_hash->nlink);
 			} else {
diff -urN cdrtools-3.01.orig/mkisofs/match.c cdrtools-3.01/mkisofs/match.c
--- cdrtools-3.01.orig/mkisofs/match.c	2010-12-19 20:16:30.000000000 +0100
+++ cdrtools-3.01/mkisofs/match.c	2014-03-25 15:52:33.812500000 +0100
@@ -24,6 +24,11 @@
 #include <schily/libport.h>
 #include <schily/nlsdefs.h>
 #include "match.h"
+#if	(defined(__CYGWIN32__) || defined(__DJGPP__)) && defined(FNM_IGNORECASE)
+#define	__FNM_FLAGS	FNM_PATHNAME|FNM_IGNORECASE
+#else
+#define	__FNM_FLAGS	FNM_PATHNAME
+#endif
 
 struct match {
 	struct match *next;
@@ -138,7 +143,7 @@
 	register sort_match	*s_mat;
 
 	for (s_mat = s_mats; s_mat; s_mat = s_mat->next) {
-		if (fnmatch(s_mat->name, fn, FNM_PATHNAME) != FNM_NOMATCH) {
+		if (fnmatch(s_mat->name, fn, __FNM_FLAGS) != FNM_NOMATCH) {
 			return (s_mat->val); /* found sort value */
 		}
 	}
@@ -351,7 +356,7 @@
 		return (0);
 
 	for (mat = mats[n]; mat; mat = mat->next) {
-		if (fnmatch(mat->name, fn, FNM_PATHNAME) != FNM_NOMATCH) {
+		if (fnmatch(mat->name, fn, __FNM_FLAGS) != FNM_NOMATCH) {
 			return (1);	/* found -> excluded filename */
 		}
 	}
diff -urN cdrtools-3.01.orig/mkisofs/md5.h cdrtools-3.01/mkisofs/md5.h
--- cdrtools-3.01.orig/mkisofs/md5.h	1970-01-01 01:00:00.000000000 +0100
+++ cdrtools-3.01/mkisofs/md5.h	2014-03-25 15:52:33.828125000 +0100
@@ -0,0 +1,36 @@
+/* @(#)md5.h	1.2 99/12/19 Copyright 1998,1999 Heiko Eissfeldt */
+/* MD5.H - header file for MD5C.C
+ */
+
+/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
+rights reserved.
+
+License to copy and use this software is granted provided that it
+is identified as the "RSA Data Security, Inc. MD5 Message-Digest
+Algorithm" in all material mentioning or referencing this software
+or this function.
+
+License is also granted to make and use derivative works provided
+that such works are identified as "derived from the RSA Data
+Security, Inc. MD5 Message-Digest Algorithm" in all material
+mentioning or referencing the derived work.
+
+RSA Data Security, Inc. makes no representations concerning either
+the merchantability of this software or the suitability of this
+software for any particular purpose. It is provided "as is"
+without express or implied warranty of any kind.
+
+These notices must be retained in any copies of any part of this
+documentation and/or software.
+ */
+
+/* MD5 context. */
+typedef struct {
+  UINT4 state[4];                                   /* state (ABCD) */
+  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
+  unsigned char buffer[64];                         /* input buffer */
+} MD5_CTX;
+
+void MD5Init __PR((MD5_CTX *));
+void MD5Update __PR((MD5_CTX *, unsigned char *, unsigned int));
+void MD5Final __PR((unsigned char [16], MD5_CTX *));
diff -urN cdrtools-3.01.orig/mkisofs/md5c.c cdrtools-3.01/mkisofs/md5c.c
--- cdrtools-3.01.orig/mkisofs/md5c.c	1970-01-01 01:00:00.000000000 +0100
+++ cdrtools-3.01/mkisofs/md5c.c	2014-03-25 15:52:33.843750000 +0100
@@ -0,0 +1,340 @@
+/* @(#)md5c.c	1.3 02/05/21 Copyright 1998,1999 Heiko Eissfeldt */
+#ifndef lint
+static char     sccsid[] =
+"@(#)md5c.c	1.3 02/05/21 Copyright 1998,1999 Heiko Eissfeldt";
+
+#endif
+/* MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm
+ */
+
+/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
+rights reserved.
+
+License to copy and use this software is granted provided that it
+is identified as the "RSA Data Security, Inc. MD5 Message-Digest
+Algorithm" in all material mentioning or referencing this software
+or this function.
+
+License is also granted to make and use derivative works provided
+that such works are identified as "derived from the RSA Data
+Security, Inc. MD5 Message-Digest Algorithm" in all material
+mentioning or referencing the derived work.
+
+RSA Data Security, Inc. makes no representations concerning either
+the merchantability of this software or the suitability of this
+software for any particular purpose. It is provided "as is"
+without express or implied warranty of any kind.
+
+These notices must be retained in any copies of any part of this
+documentation and/or software.
+ */
+
+#include "config.h"
+#include "mytype.h"
+#include "md5.h"
+
+/* Constants for MD5Transform routine.
+ */
+#define S11 7L
+#define S12 12L
+#define S13 17L
+#define S14 22L
+#define S21 5L
+#define S22 9L
+#define S23 14L
+#define S24 20L
+#define S31 4L
+#define S32 11L
+#define S33 16L
+#define S34 23L
+#define S41 6L
+#define S42 10L
+#define S43 15L
+#define S44 21L
+
+typedef unsigned char * POINTER;
+
+static void MD5Transform __PR((UINT4 [4], unsigned char [64]));
+static void Encode __PR((unsigned char *, UINT4 *, unsigned int));
+static void Decode __PR((UINT4 *, unsigned char *, unsigned int));
+static void MD5_memcpy __PR((POINTER, POINTER, unsigned int));
+static void MD5_memset __PR((POINTER, int, unsigned int));
+
+static unsigned char PADDING[64] = {
+  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+/* F, G, H and I are basic MD5 functions.
+ */
+#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
+#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
+#define H(x, y, z) ((x) ^ (y) ^ (z))
+#define I(x, y, z) ((y) ^ ((x) | (~z)))
+
+/* ROTATE_LEFT rotates x left n bits.
+ */
+#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32L-(n))))
+
+/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
+Rotation is separate from addition to prevent recomputation.
+ */
+#define FF(a, b, c, d, x, s, ac) { \
+ (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
+ (a) = ROTATE_LEFT ((a), (s)); \
+ (a) += (b); \
+  }
+#define GG(a, b, c, d, x, s, ac) { \
+ (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
+ (a) = ROTATE_LEFT ((a), (s)); \
+ (a) += (b); \
+  }
+#define HH(a, b, c, d, x, s, ac) { \
+ (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
+ (a) = ROTATE_LEFT ((a), (s)); \
+ (a) += (b); \
+  }
+#define II(a, b, c, d, x, s, ac) { \
+ (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
+ (a) = ROTATE_LEFT ((a), (s)); \
+ (a) += (b); \
+  }
+
+/* MD5 initialization. Begins an MD5 operation, writing a new context.
+ */
+void MD5Init (context)
+MD5_CTX *context;                                        /* context */
+{
+  context->count[0] = context->count[1] = 0;
+  /* Load magic initialization constants.
+*/
+  context->state[0] = UINT4_C(0x67452301);
+  context->state[1] = UINT4_C(0xefcdab89);
+  context->state[2] = UINT4_C(0x98badcfe);
+  context->state[3] = UINT4_C(0x10325476);
+}
+
+/* MD5 block update operation. Continues an MD5 message-digest
+  operation, processing another message block, and updating the
+  context.
+ */
+void MD5Update (context, input, inputLen)
+MD5_CTX *context;                                        /* context */
+unsigned char *input;                                /* input block */
+unsigned int inputLen;                     /* length of input block */
+{
+  unsigned int i, indx, partLen;
+
+  /* Compute number of bytes mod 64 */
+  indx = (unsigned int)((context->count[0] >> 3L) & 0x3F);
+
+  /* Update number of bits */
+  if ((context->count[0] += ((UINT4)inputLen << 3L))
+   < ((UINT4)inputLen << 3L))
+ context->count[1]++;
+  context->count[1] += ((UINT4)inputLen >> 29L);
+
+  partLen = 64 - indx;
+
+  /* Transform as many times as possible.
+*/
+  if (inputLen >= partLen) {
+ MD5_memcpy
+   ((POINTER)&context->buffer[indx], (POINTER)input, partLen);
+ MD5Transform (context->state, context->buffer);
+
+ for (i = partLen; i + 63 < inputLen; i += 64)
+   MD5Transform (context->state, &input[i]);
+
+ indx = 0;
+  }
+  else
+ i = 0;
+
+  /* Buffer remaining input */
+  MD5_memcpy
+ ((POINTER)&context->buffer[indx], (POINTER)&input[i],
+  inputLen-i);
+}
+
+/* MD5 finalization. Ends an MD5 message-digest operation, writing the
+  the message digest and zeroizing the context.
+ */
+void MD5Final (digest, context)
+unsigned char digest[16];                         /* message digest */
+MD5_CTX *context;                                       /* context */
+{
+  unsigned char bits[8];
+  unsigned int indx, padLen;
+
+  /* Save number of bits */
+  Encode (bits, context->count, 8);
+
+  /* Pad out to 56 mod 64.
+*/
+  indx = (unsigned int)((context->count[0] >> 3L) & 0x3f);
+  padLen = (indx < 56) ? (56 - indx) : (120 - indx);
+  MD5Update (context, PADDING, padLen);
+
+  /* Append length (before padding) */
+  MD5Update (context, bits, 8);
+  /* Store state in digest */
+  Encode (digest, context->state, 16);
+
+  /* Zeroize sensitive information.
+*/
+  MD5_memset ((POINTER)context, 0, sizeof (*context));
+}
+
+/* MD5 basic transformation. Transforms state based on block.
+ */
+static void MD5Transform (state, block)
+UINT4 state[4];
+unsigned char block[64];
+{
+  UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];
+
+  Decode (x, block, 64);
+
+  /* Round 1 */
+  FF (a, b, c, d, x[ 0], S11, UINT4_C(0xd76aa478)); /* 1 */
+  FF (d, a, b, c, x[ 1], S12, UINT4_C(0xe8c7b756)); /* 2 */
+  FF (c, d, a, b, x[ 2], S13, UINT4_C(0x242070db)); /* 3 */
+  FF (b, c, d, a, x[ 3], S14, UINT4_C(0xc1bdceee)); /* 4 */
+  FF (a, b, c, d, x[ 4], S11, UINT4_C(0xf57c0faf)); /* 5 */
+  FF (d, a, b, c, x[ 5], S12, UINT4_C(0x4787c62a)); /* 6 */
+  FF (c, d, a, b, x[ 6], S13, UINT4_C(0xa8304613)); /* 7 */
+  FF (b, c, d, a, x[ 7], S14, UINT4_C(0xfd469501)); /* 8 */
+  FF (a, b, c, d, x[ 8], S11, UINT4_C(0x698098d8)); /* 9 */
+  FF (d, a, b, c, x[ 9], S12, UINT4_C(0x8b44f7af)); /* 10 */
+  FF (c, d, a, b, x[10], S13, UINT4_C(0xffff5bb1)); /* 11 */
+  FF (b, c, d, a, x[11], S14, UINT4_C(0x895cd7be)); /* 12 */
+  FF (a, b, c, d, x[12], S11, UINT4_C(0x6b901122)); /* 13 */
+  FF (d, a, b, c, x[13], S12, UINT4_C(0xfd987193)); /* 14 */
+  FF (c, d, a, b, x[14], S13, UINT4_C(0xa679438e)); /* 15 */
+  FF (b, c, d, a, x[15], S14, UINT4_C(0x49b40821)); /* 16 */
+
+ /* Round 2 */
+  GG (a, b, c, d, x[ 1], S21, UINT4_C(0xf61e2562)); /* 17 */
+  GG (d, a, b, c, x[ 6], S22, UINT4_C(0xc040b340)); /* 18 */
+  GG (c, d, a, b, x[11], S23, UINT4_C(0x265e5a51)); /* 19 */
+  GG (b, c, d, a, x[ 0], S24, UINT4_C(0xe9b6c7aa)); /* 20 */
+  GG (a, b, c, d, x[ 5], S21, UINT4_C(0xd62f105d)); /* 21 */
+  GG (d, a, b, c, x[10], S22, UINT4_C( 0x2441453)); /* 22 */
+  GG (c, d, a, b, x[15], S23, UINT4_C(0xd8a1e681)); /* 23 */
+  GG (b, c, d, a, x[ 4], S24, UINT4_C(0xe7d3fbc8)); /* 24 */
+  GG (a, b, c, d, x[ 9], S21, UINT4_C(0x21e1cde6)); /* 25 */
+  GG (d, a, b, c, x[14], S22, UINT4_C(0xc33707d6)); /* 26 */
+  GG (c, d, a, b, x[ 3], S23, UINT4_C(0xf4d50d87)); /* 27 */
+  GG (b, c, d, a, x[ 8], S24, UINT4_C(0x455a14ed)); /* 28 */
+  GG (a, b, c, d, x[13], S21, UINT4_C(0xa9e3e905)); /* 29 */
+  GG (d, a, b, c, x[ 2], S22, UINT4_C(0xfcefa3f8)); /* 30 */
+  GG (c, d, a, b, x[ 7], S23, UINT4_C(0x676f02d9)); /* 31 */
+  GG (b, c, d, a, x[12], S24, UINT4_C(0x8d2a4c8a)); /* 32 */
+
+  /* Round 3 */
+  HH (a, b, c, d, x[ 5], S31, UINT4_C(0xfffa3942)); /* 33 */
+  HH (d, a, b, c, x[ 8], S32, UINT4_C(0x8771f681)); /* 34 */
+  HH (c, d, a, b, x[11], S33, UINT4_C(0x6d9d6122)); /* 35 */
+  HH (b, c, d, a, x[14], S34, UINT4_C(0xfde5380c)); /* 36 */
+  HH (a, b, c, d, x[ 1], S31, UINT4_C(0xa4beea44)); /* 37 */
+  HH (d, a, b, c, x[ 4], S32, UINT4_C(0x4bdecfa9)); /* 38 */
+  HH (c, d, a, b, x[ 7], S33, UINT4_C(0xf6bb4b60)); /* 39 */
+  HH (b, c, d, a, x[10], S34, UINT4_C(0xbebfbc70)); /* 40 */
+  HH (a, b, c, d, x[13], S31, UINT4_C(0x289b7ec6)); /* 41 */
+  HH (d, a, b, c, x[ 0], S32, UINT4_C(0xeaa127fa)); /* 42 */
+  HH (c, d, a, b, x[ 3], S33, UINT4_C(0xd4ef3085)); /* 43 */
+  HH (b, c, d, a, x[ 6], S34, UINT4_C( 0x4881d05)); /* 44 */
+  HH (a, b, c, d, x[ 9], S31, UINT4_C(0xd9d4d039)); /* 45 */
+  HH (d, a, b, c, x[12], S32, UINT4_C(0xe6db99e5)); /* 46 */
+  HH (c, d, a, b, x[15], S33, UINT4_C(0x1fa27cf8)); /* 47 */
+  HH (b, c, d, a, x[ 2], S34, UINT4_C(0xc4ac5665)); /* 48 */
+
+  /* Round 4 */
+  II (a, b, c, d, x[ 0], S41, UINT4_C(0xf4292244)); /* 49 */
+  II (d, a, b, c, x[ 7], S42, UINT4_C(0x432aff97)); /* 50 */
+  II (c, d, a, b, x[14], S43, UINT4_C(0xab9423a7)); /* 51 */
+  II (b, c, d, a, x[ 5], S44, UINT4_C(0xfc93a039)); /* 52 */
+  II (a, b, c, d, x[12], S41, UINT4_C(0x655b59c3)); /* 53 */
+  II (d, a, b, c, x[ 3], S42, UINT4_C(0x8f0ccc92)); /* 54 */
+  II (c, d, a, b, x[10], S43, UINT4_C(0xffeff47d)); /* 55 */
+  II (b, c, d, a, x[ 1], S44, UINT4_C(0x85845dd1)); /* 56 */
+  II (a, b, c, d, x[ 8], S41, UINT4_C(0x6fa87e4f)); /* 57 */
+  II (d, a, b, c, x[15], S42, UINT4_C(0xfe2ce6e0)); /* 58 */
+  II (c, d, a, b, x[ 6], S43, UINT4_C(0xa3014314)); /* 59 */
+  II (b, c, d, a, x[13], S44, UINT4_C(0x4e0811a1)); /* 60 */
+  II (a, b, c, d, x[ 4], S41, UINT4_C(0xf7537e82)); /* 61 */
+  II (d, a, b, c, x[11], S42, UINT4_C(0xbd3af235)); /* 62 */
+  II (c, d, a, b, x[ 2], S43, UINT4_C(0x2ad7d2bb)); /* 63 */
+  II (b, c, d, a, x[ 9], S44, UINT4_C(0xeb86d391)); /* 64 */
+
+  state[0] += a;
+  state[1] += b;
+  state[2] += c;
+  state[3] += d;
+
+  /* Zeroize sensitive information.
+*/
+  MD5_memset ((POINTER)x, 0, sizeof (x));
+}
+
+/* Encodes input (UINT4) into output (unsigned char). Assumes len is
+  a multiple of 4.
+ */
+static void Encode (output, input, len)
+unsigned char *output;
+UINT4 *input;
+unsigned int len;
+{
+  unsigned int i, j;
+
+  for (i = 0, j = 0; j < len; i++, j += 4) {
+ output[j] = (unsigned char)(input[i] & 0xff);
+ output[j+1] = (unsigned char)((input[i] >> 8L) & 0xff);
+ output[j+2] = (unsigned char)((input[i] >> 16L) & 0xff);
+ output[j+3] = (unsigned char)((input[i] >> 24L) & 0xff);
+  }
+}
+
+/* Decodes input (unsigned char) into output (UINT4). Assumes len is
+  a multiple of 4.
+ */
+static void Decode (output, input, len)
+UINT4 *output;
+unsigned char *input;
+unsigned int len;
+{
+  unsigned int i, j;
+
+  for (i = 0, j = 0; j < len; i++, j += 4)
+ output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) << 8L) |
+   (((UINT4)input[j+2]) << 16L) | (((UINT4)input[j+3]) << 24L);
+}
+
+/* Note: Replace "for loop" with standard memcpy if possible.
+ */
+
+static void MD5_memcpy (output, input, len)
+POINTER output;
+POINTER input;
+unsigned int len;
+{
+  unsigned int i;
+
+  for (i = 0; i < len; i++)
+ output[i] = input[i];
+}
+
+/* Note: Replace "for loop" with standard memset if possible.
+ */
+static void MD5_memset (output, value, len)
+POINTER output;
+int value;
+unsigned int len;
+{
+  unsigned int i;
+
+  for (i = 0; i < len; i++)
+ ((char *)output)[i] = (char)value;
+}
diff -urN cdrtools-3.01.orig/mkisofs/mkisofs.c cdrtools-3.01/mkisofs/mkisofs.c
--- cdrtools-3.01.orig/mkisofs/mkisofs.c	2014-02-11 23:38:45.000000000 +0100
+++ cdrtools-3.01/mkisofs/mkisofs.c	2014-03-25 15:52:33.859375000 +0100
@@ -32,6 +32,8 @@
 /* MAC UDF images by HELIOS Software GmbH support@helios.de */
 /* HFS+ by HELIOS Software GmbH support@helios.de */
 
+/* DUPLICATES_ONCE Alex Kopylov cdrtools@bootcd.ru 19.06.2004 */
+
 #ifdef	USE_FIND
 #include <schily/walk.h>
 #include <schily/find.h>
@@ -316,6 +318,14 @@
 BOOL	rrip112 = TRUE;		/* TRUE: create Rock Ridge V 1.12	    */
 BOOL	long_rr_time = FALSE;	/* TRUE: use long (17 Byte) time format	    */
 
+#ifdef	DUPLICATES_ONCE
+int	duplicates_once = 0;	/* encode duplicate files once */
+#endif
+
+#ifdef	FORCE_UPPERCASE
+int	force_uppercase = 0;	/* Force upper cased names */
+#endif
+
 siconvt_t	*in_nls = NULL;  /* input UNICODE conversion table */
 siconvt_t	*out_nls = NULL; /* output UNICODE conversion table */
 #ifdef APPLE_HYB
@@ -1092,6 +1102,10 @@
 	__("Create old Rock Ridge V 1.10")},
 	{{"rrip112", &rrip112 },
 	__("Create new Rock Ridge V 1.12 (default)")},
+#ifdef	DUPLICATES_ONCE
+	{{"duplicates-once", &duplicates_once},
+	__("Optimize storage by encoding duplicate files once")},
+#endif
 	{{"check-oldnames", &check_oldnames },
 	__("Check all imported ISO9660 names from old session")},
 	{{"check-session*", &check_image },
@@ -1298,6 +1312,10 @@
 	__("Do not translate illegal ISO characters '~', '-' and '#' (violates ISO9660)")},
 	{{"allow-lowercase", &allow_lowercase },
 	__("Allow lower case characters in addition to the current character set (violates ISO9660)")},
+#ifdef	FORCE_UPPERCASE
+	{{"force-uppercase", &force_uppercase},
+	__("Do not allow lower case characters")},
+#endif
 	{{"allow-multidot", &allow_multidot },
 	__("Allow more than one dot in filenames (e.g. .tar.gz) (violates ISO9660)")},
 	{{"use-fileversion", &use_fileversion },
@@ -1997,6 +2015,10 @@
 #endif
 	save_args(argc, argv);
 
+#if	defined(IS_CYGWIN) || defined(__DJGPP__) || defined(__MINGW32__)
+	set_progname("mkisofs");
+#endif
+
 #if	defined(USE_NLS)
 	setlocale(LC_ALL, "");
 #if !defined(TEXT_DOMAIN)	/* Should be defined by cc -D */
@@ -2072,7 +2094,7 @@
 	if (help)
 		usage(0);
 	if (pversion) {
-		printf(_("mkisofs %s (%s-%s-%s) Copyright (C) 1993-1997 %s (C) 1997-2014 %s\n"),
+		printf(_("mkisofs %s (%s-%s-%s)-bootcd.ru Copyright (C) 1993-1997 %s (C) 1997-2014 %s\n"),
 			version_string,
 			HOST_CPU, HOST_VENDOR, HOST_OS,
 			_("Eric Youngdale"),
@@ -2154,6 +2176,14 @@
 	}
 	if (!cache_inodes) {
 		correct_inodes = FALSE;
+#if	defined(__MINGW32__)
+	} else {
+		errmsgno(EX_BAD,
+		_("Warning: cannot -cache-inodes on this platform - ignoring.\n"));
+		cache_inodes = 0;
+		correct_inodes = FALSE;
+	}
+#else
 		if (use_RockRidge) {
 			errmsgno(EX_BAD,
 			_("Warning: Cannot write inode/link information with -no-cache-inodes.\n"));
@@ -2162,6 +2192,7 @@
 			_("Warning: Cannot add inode hints with -no-cache-inodes.\n"));
 		}
 	}
+#endif
 	if (!correct_inodes)
 		rrip112 = FALSE;
 	if (check_image) {
@@ -2644,6 +2675,7 @@
 	if (use_RockRidge && (iso9660_namelen > MAX_ISONAME_V2_RR))
 		iso9660_namelen = MAX_ISONAME_V2_RR;
 
+#if	(!defined(__CYGWIN32__) && !defined(__CYGWIN__) && !defined(__MINGW32__))
 	if (warn_violate)
 		error(_("Warning: creating filesystem that does not conform to ISO-9660.\n"));
 	if (iso9660_level > 3)
@@ -2656,6 +2688,7 @@
 		error(_("         but without (standard) Rock Ridge extensions.\n"));
 		error(_("         It is highly recommended to add Rock Ridge\n"));
 	}
+#endif
 	if (transparent_compression) {
 		error(_("Warning: using transparent compression. This is a nonstandard Rock Ridge\n"));
 		error(_("         extension. The resulting filesystem can only be transparently\n"));
@@ -2836,6 +2869,22 @@
 	mem_start = (unsigned long) sbrk(0);
 #endif
 
+#ifdef	FORCE_UPPERCASE
+	if (force_uppercase) {
+		allow_lowercase = 0;
+	}
+#endif
+
+/* crude hack */
+#if	defined(__MINGW32__)
+	if (merge_image == NULL) {
+		remove(outfile);
+		if (verbose > 2) {
+			fprintf(stderr, "remove file '%s'.\n", outfile);
+		}
+	}
+#endif
+
 	if (verbose > 1) {
 		fprintf(stderr, "%s (%s-%s-%s)\n",
 				version_string,
diff -urN cdrtools-3.01.orig/mkisofs/mkisofs.h cdrtools-3.01/mkisofs/mkisofs.h
--- cdrtools-3.01.orig/mkisofs/mkisofs.h	2013-04-25 23:10:08.000000000 +0200
+++ cdrtools-3.01/mkisofs/mkisofs.h	2014-03-25 15:52:33.859375000 +0100
@@ -24,6 +24,8 @@
 
 /* APPLE_HYB James Pearson j.pearson@ge.ucl.ac.uk 23/2/2000 */
 
+/* DUPLICATES_ONCE Alex Kopylov cdrtools@bootcd.ru 19.06.2004 */
+
 #include <schily/mconfig.h>	/* Must be before stdio.h for LARGEFILE support */
 #include <schily/stdio.h>
 #include <schily/types.h>
@@ -40,6 +42,12 @@
 #include <schily/libport.h>	/* Define missing prototypes */
 #include "scsi.h"
 
+#ifdef	DUPLICATES_ONCE
+#include "config.h"
+#include "mytype.h"
+#include "md5.h"
+#endif
+
 #ifdef	DVD_VIDEO
 #ifndef	UDF
 #define	UDF
@@ -145,16 +153,23 @@
 #ifdef UDF
 	int		udf_file_entry_sector;	/* also used as UDF unique ID */
 #endif
+#ifdef	DUPLICATES_ONCE
+	unsigned char	*md5_fast;
+	unsigned char	*md5_full;
+#endif
 };
 
 struct file_hash {
 	struct file_hash *next;
+#ifdef	DUPLICATES_ONCE
+	struct file_hash *unique_files_next;
+#endif
 	ino_t		inode;		/* Used in the hash table */
 	dev_t		dev;		/* Used in the hash table */
 	nlink_t		nlink;		/* Used to compute new link count */
 	unsigned int	starting_block;
 	off_t		size;
-#ifdef SORTING
+#if	defined(SORTING) || defined(DUPLICATES_ONCE)
 	struct directory_entry *de;
 #endif /* SORTING */
 };
@@ -376,6 +391,9 @@
 extern int	new_dir_mode;
 extern int	follow_links;
 extern int	cache_inodes;
+#ifdef	DUPLICATES_ONCE
+extern int duplicates_once;
+#endif
 extern int	verbose;
 extern int	debug;
 extern int	gui;
@@ -584,7 +602,7 @@
 extern int iso9660_date __PR((char *, time_t));
 extern int iso9660_ldate __PR((char *, time_t, int, int));
 extern void add_hash __PR((struct directory_entry *));
-extern struct file_hash *find_hash __PR((dev_t, ino_t));
+extern struct file_hash *find_hash __PR((struct directory_entry *));
 
 extern void flush_hash __PR((void));
 extern void add_directory_hash __PR((dev_t, ino_t));
diff -urN cdrtools-3.01.orig/mkisofs/mytype.h cdrtools-3.01/mkisofs/mytype.h
--- cdrtools-3.01.orig/mkisofs/mytype.h	1970-01-01 01:00:00.000000000 +0100
+++ cdrtools-3.01/mkisofs/mytype.h	2014-03-25 15:52:33.859375000 +0100
@@ -0,0 +1,27 @@
+/* @(#)mytype.h	1.2 99/12/19 Copyright 1998,1999 Heiko Eissfeldt */
+#if 4 == SIZEOF_LONG_INT
+#define UINT4 long unsigned int
+#define UINT4_C ULONG_C
+#else
+#if 4 == SIZEOF_INT
+#define UINT4 unsigned int
+#define UINT4_C UINT_C
+#else
+#if 4 == SIZEOF_SHORT_INT
+#define UINT4 short unsigned int
+#define UINT4_C USHORT_C
+#else
+error need an integer type with 32 bits, but do not know one!
+#endif
+#endif
+#endif
+#define TRUE 1
+#define FALSE 0
+
+#ifndef offset_of
+#define offset_of(TYPE, MEMBER) ((size_t) ((TYPE *)0)->MEMBER)
+#endif
+#ifndef offsetof
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+#endif
+
diff -urN cdrtools-3.01.orig/mkisofs/tree.c cdrtools-3.01/mkisofs/tree.c
--- cdrtools-3.01.orig/mkisofs/tree.c	2014-02-17 23:50:01.000000000 +0100
+++ cdrtools-3.01/mkisofs/tree.c	2014-03-25 15:52:33.875000000 +0100
@@ -31,6 +31,8 @@
 
 /* APPLE_HYB James Pearson j.pearson@ge.ucl.ac.uk 23/2/2000 */
 
+/* DUPLICATES_ONCE Alex Kopylov cdrtools@bootcd.ru 19.06.2004 */
+
 #include "mkisofs.h"
 #include "rock.h"
 #include "match.h"
@@ -1815,6 +1817,10 @@
 	s_entry->de_flags = 0;
 	if (S_ISLNK(lstatbuf.st_mode))
 		s_entry->de_flags |= IS_SYMLINK;
+#ifdef	DUPLICATES_ONCE
+	s_entry->md5_fast = NULL;
+	s_entry->md5_full = NULL;
+#endif
 
 	/*
 	 * If the current directory is hidden, then hide all it's members
diff -urN cdrtools-3.01.orig/mkisofs/udf.c cdrtools-3.01/mkisofs/udf.c
--- cdrtools-3.01.orig/mkisofs/udf.c	2013-04-24 22:45:18.000000000 +0200
+++ cdrtools-3.01/mkisofs/udf.c	2014-03-25 15:52:33.875000000 +0100
@@ -1889,7 +1889,7 @@
 				}
 #endif
 				if (correct_inodes &&
-				    (s_hash = find_hash(de->dev, de->inode)) != NULL) {
+				    (s_hash = find_hash(dpnt->contents)) != NULL) {
 					nlink = s_hash->nlink;
 					file_id = s_hash->starting_block;
 				} else {
diff -urN cdrtools-3.01.orig/mkisofs/write.c cdrtools-3.01/mkisofs/write.c
--- cdrtools-3.01.orig/mkisofs/write.c	2014-02-11 23:36:59.000000000 +0100
+++ cdrtools-3.01/mkisofs/write.c	2014-03-25 15:52:33.890625000 +0100
@@ -29,6 +29,8 @@
 
 /* APPLE_HYB James Pearson j.pearson@ge.ucl.ac.uk 23/2/2000 */
 
+/* DUPLICATES_ONCE Alex Kopylov cdrtools@bootcd.ru 19.06.2004 */
+
 #include "mkisofs.h"
 #include <schily/time.h>
 #include <schily/fcntl.h>
@@ -944,7 +946,7 @@
 				continue;
 
 			/* update the start extent */
-			s_hash = find_hash(s_entry->dev, s_entry->inode);
+			s_hash = find_hash(s_entry);
 			if (s_hash) {
 				set_733((char *)s_entry->isorec.extent, s_hash->starting_block);
 				s_entry->starting_block = s_hash->starting_block;
@@ -1116,7 +1118,7 @@
 			 * If this is a multi-extent file, we get mxpart == 1
 			 * from find_hash().
 			 */
-			s_hash = find_hash(s_entry->dev, s_entry->inode);
+			s_hash = find_hash(s_entry);
 			if (s_hash) {
 				if (verbose > 2) {
 					fprintf(stderr, _("Cache hit for '%s%s%s'\n"),
@@ -1485,6 +1487,18 @@
 		}
 #endif	/* APPLE_HYB */
 
+#ifdef	DUPLICATES_ONCE
+		if(s_entry_d->md5_fast) {
+
+			if(s_entry_d->md5_full && (s_entry_d->md5_full != s_entry_d->md5_fast))
+				free(s_entry_d->md5_full);
+
+			free(s_entry_d->md5_fast);
+
+			s_entry_d->md5_fast = NULL;
+			s_entry_d->md5_full = NULL;
+		}
+#endif
 		free(s_entry_d);
 		s_entry_d = NULL;
 	}
@@ -2870,7 +2884,7 @@
 			 * find any cached entry and assign new starting
 			 * extent
 			 */
-			s_hash = find_hash(s_entry->dev, s_entry->inode);
+			s_hash = find_hash(s_entry);
 			if (s_hash) {
 				set_733((char *)s_entry->isorec.extent,
 						s_hash->starting_block);
diff -urN cdrtools-3.01.orig/readme.1st cdrtools-3.01/readme.1st
--- cdrtools-3.01.orig/readme.1st	1970-01-01 01:00:00.000000000 +0100
+++ cdrtools-3.01/readme.1st	2014-03-25 15:52:33.890625000 +0100
@@ -0,0 +1,22 @@
+
+Original cdrtools by Joerg Schilling
+
+=====================================================================
+
+NOTE:
+This version of cdrtools is an inofficial (modified) release and 
+thus may have bugs that are not present in the original version.
+The original author should not be bothered with problems of this version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+GNU General Public License for more details.
+
+Differences to original version:
+
+- New mkisofs options:
+
+  -duplicates-once	Optimize storage by encoding duplicate files once
+
+  -force-uppercase	Do not allow lower case characters
